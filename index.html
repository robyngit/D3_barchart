<!DOCTYPE html>
<meta charset="utf-8">
<style>


/******************************************
* Metric Modal Chart (Views, Downloads, Citations)
********************************************/

/* When there is no data ...*/

#metric-modal .metric-chart text {
	fill: #565656;
	font-size: 9px;
	font-family: Helvetica, Arial, "sans serif";
}

#metric-modal .metric-chart text.no-data {
	font-size: 16px;
	font-weight: 100;
	fill:#d0d0d0;
}

#metric-modal .metric-chart rect.no-data {
	fill: #f5f5f5;
}

/* When there is data ...*/

/* CB: padding to display better on bl.ocks.org */
#metric-modal {
	padding: 64px;
}

#metric-modal .metric-chart rect.plot-background{
	fill: white;
}

#metric-modal .metric-chart .axis {
	shape-rendering: crispEdges;
}

#metric-modal .metric-chart .x.axis {
	clip-path: url(#clip);
}

#metric-modal .metric-chart .x.axis .domain{
	display:none;
}

#metric-modal .metric-chart .x.axis line {
	stroke: white;
	opacity: 0.4;
}

#metric-modal .metric-chart .context .x.axis line {
	display: none;
}

#metric-modal .metric-chart .y.axis .domain{
	display: none;
}

#metric-modal .metric-chart .y.axis.title{
	font-size: 13px;
	font-weight: 100;
}

#metric-modal .metric-chart .y.axis line {
	stroke: #565656;
	stroke-dasharray: 2,2;
	stroke-opacity: 0.3;
}

#metric-modal .metric-chart .brush .extent {
  fill-opacity: .07;
  shape-rendering: crispEdges;
  clip-path: url(#clip);
}

#metric-modal .metric-chart rect.pane {
	cursor: move; /* fallback if grab cursor is unsupported */
	cursor: grab;
	fill: white;
	pointer-events: all;
}

#metric-modal .metric-chart rect.pane:active {
	cursor: move; /* fallback if grab cursor is unsupported */
	cursor: grabbing;
}

/* brush handles  */
#metric-modal .metric-chart .resize .handle {
	fill: #555;
}

#metric-modal .metric-chart .resize .handle-mini {
	fill: white;
    stroke-width: 1px;
    stroke: #555;
}

#metric-modal .metric-chart .scale_button {
	cursor: pointer;
}

#metric-modal .metric-chart .scale_button rect {
	fill: #eaeaea;
}
#metric-modal .metric-chart .scale_button:hover text {
	fill: #417DD6;
	transition: all 0.1s cubic-bezier(.25,.8,.25,1);
}

#metric-modal .metric-chart text#displayDates  {
	font-weight: bold;
}

/* bars */
#metric-modal .metric-chart .bar {
	fill: #00AA8D;
	/* stroke: ; /* default, changed in each theme */ */
	stroke-width: 1.5px;
	clip-path: url(#clip);
	cursor: default;
	transition: stroke-width 0.06s ease-in;
	transition: stroke 0.06s ease-in;
}

#metric-modal .metric-chart .bar:hover {
	stroke: #00997e;
	stroke-width: 1px;
	transition: stroke-width 0.06s ease-out;
	transition: stroke 0.06s ease-out;
}

/* circle style */
#metric-modal .metric-chart .contextbar {
	fill: #00AA8D;
}

div.tooltip {
    position: fixed;
    text-align: center;
    width: 60px;
    height: 25px;
    padding: 2px;
    font: 10px sans-serif;
    background: white;
	color: #565656;
    border: 0px;
    border-radius: 2px;
    pointer-events: none;
	box-shadow: 0 0px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);

}

</style>
<body>
<div id="metric-modal"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>

// example data
var metricName   = "views";
var metricCount  = [1, 3, 1, 2, 1, 1, 1, 1, 2, 2, 3, 1, 2, 1, 4, 3, 2, 1, 1, 1, 1, 1, 4, 2, 1, 2, 8, 2, 1, 4, 2, 4, 1, 3, 1, 2, 1, 1, 3, 1, 1, 5, 1, 1, 4];
var metricMonths = ["2018-06", "2013-04", "2015-11", "2012-10", "2014-09", "2014-02", "2016-02", "2016-04", "2016-06", "2014-12", "2013-07", "2017-01", "2015-10", "2012-12", "2013-05", "2018-04", "2015-06", "2017-03", "2014-08",
                    "2017-07", "2013-02", "2012-07", "2016-03", "2017-06", "2018-07", "2014-10", "2013-01", "2013-10", "2017-11", "2014-05", "2012-11", "2015-01", "2018-03", "2015-12", "2015-08", "2016-08", "2014-11", "2014-01",
                    "2013-06", "2012-08", "2015-09", "2016-07", "2013-03", "2012-09", "2016-05"];
var optwidth        = 600;
var optheight       = 370;


/*
* ========================================================================
*  Prepare data
* ========================================================================
*/

// Combine the months and count array to make "data"
var dataset = [];

for(var i=0; i<metricCount.length; i++){

	var monthStart = d3.time.format("%Y-%m").parse(metricMonths[i]);
	var monthMid   = d3.time.day.offset(monthStart, -10);

    var obj = {
		count:	metricCount[i],
		month:  monthStart
	};

    dataset.push(obj);
}

// sort dataset by month
dataset.sort(function(x, y){
   return d3.ascending(x.month, y.month);
});

/*
* ========================================================================
*  sizing
* ========================================================================
*/

/* === Focus chart === */

var margin	= {top: 20, right: 30, bottom: 100, left: 20},
    width	= optwidth - margin.left - margin.right,
    height	= optheight - margin.top - margin.bottom;

/* === Context chart === */

var margin_context = {top: 320, right: 30, bottom: 20, left: 20},
    height_context = optheight - margin_context.top - margin_context.bottom;

/*
* ========================================================================
*  x and y coordinates
* ========================================================================
*/

// the date range of available data:
var dataXrange = d3.extent(dataset, function(d) { return d.month; });
var dataYrange = [0, d3.max(dataset, function(d) { return d.count; })];

// maximum date range allowed to display
var mindate = dataXrange[0],  // use the range of the data
    maxdate = dataXrange[1];

var DateFormat	  =  d3.time.format("%b %Y");

/* === Focus Chart === */

var x = d3.time.scale()
	.range([0, width])
    .domain(dataXrange);//dataset.map(function(d){ return d.month})

// This fake ordianal scale is used only because of its `rangeBands` method
// to automatially calculate the width of columns of column chart
// for details, see: https://stackoverflow.com/questions/12186366/d3-js-evenly-spaced-bars-on-a-time-scale
var x_ordinal = d3.scale.ordinal()
	.rangeBands([0, width], .6)
    .domain(dataset.map(function(d){ return d.month}));

var y = d3.scale.linear()
	.range([height, 0])
    .domain(dataYrange);

var xAxis = d3.svg.axis()
	.scale(x)
    .orient("bottom")
	.tickSize(-(height))
    .ticks(customTickFunction)
	.tickFormat(format_months);

function format_months(d){

	var test = (x.domain()[1] - x.domain()[0]) > 132167493818;

	//console.log(test);

	if(d.getMonth()==0 & test){//if january
		var yearOnly = d3.time.format("%Y");
		return(yearOnly(d));
	} else {
		return(DateFormat(d))
	}
}


var yAxis = d3.svg.axis()
	.scale(y)
    .ticks(4)
    .tickSize(-(width))
	.orient("right");

/* === Context Chart === */

var x_context = d3.time.scale()
    .range([0, width])
    .domain([mindate, maxdate]);

var x_context_ordinal = d3.scale.ordinal()
	.rangeBands([0, width], .6)
    .domain(dataset.map(function(d){ return d.month}));

var y_context = d3.scale.linear()
	.range([height_context, 0])
    .domain(y.domain());

var xAxis_context = d3.svg.axis()
    .scale(x_context)
    .orient("bottom")
    .ticks(customTickFunction)
    .tickFormat(format_months);

/*
* ========================================================================
*  Variables for brushing and zooming behaviour
* ========================================================================
*/

var brush = d3.svg.brush()
    .x(x_context)
    .on("brush", brushed)
    .on("brushend", brushend);

var zoom = d3.behavior.zoom()
    .on("zoom", draw)
    .on("zoomend", brushend);

/*
* ========================================================================
*  Define the SVG area ("vis") and append all the layers
* ========================================================================
*/

// === the main components === //

var vis = d3.select("#metric-modal").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  	.attr("class", "metric-chart");// CB -- "line-chart" -- CB //

vis.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("width", width)
    .attr("height", height);
    // clipPath is used to keep elements from moving outside of plot area when user zooms/scrolls/brushes

var pane = vis.append("svg:rect")
    .attr("class", "pane")
    .attr("width", width)
    .attr("height", height)
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var context = vis.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin_context.left + "," + margin_context.top + ")");

var focus = vis.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

pane.call(zoom)
	.call(draw);

// === current date range text & zoom buttons === //

var display_range_group = vis.append("g")
    .attr("id", "buttons_group")
    .attr("transform", "translate(" + 0 + ","+ 0 +")");

var expl_text = display_range_group.append("text")
    .text("Showing data from: ")
    .style("text-anchor", "start")
    .attr("transform", "translate(" + 0 + ","+ 10 +")");

display_range_group.append("text")
    .attr("id", "displayDates")
    .text(DateFormat(dataXrange[0]) + " - " + DateFormat(dataXrange[1]))
    .style("text-anchor", "start")
    .attr("transform", "translate(" + 82 + ","+ 10 +")");

var expl_text = display_range_group.append("text")
    .text("Zoom to: ")
    .style("text-anchor", "start")
    .attr("transform", "translate(" + 180 + ","+ 10 +")");

// === the zooming/scaling buttons === //

var button_width = 40;
var button_height = 14;

// don't show year button if < 1 year of data
var dateRange  = dataXrange[1] - dataXrange[0],
    ms_in_year = 31540000000;

if (dateRange < ms_in_year)   {
    var button_data =["month","data"];
} else {
    var button_data =["year","month","data"];
};

var button = display_range_group.selectAll("g")
    .data(button_data)
    .enter().append("g")
    .attr("class", "scale_button")
    .attr("transform", function(d, i) { return "translate(" + (220 + i*button_width + i*10) + ",0)"; })
    .on("click", scaleDate);

button.append("rect")
    .attr("width", button_width)
    .attr("height", button_height)
    .attr("rx", 1)
    .attr("ry", 1);

button.append("text")
    .attr("dy", (button_height/2 + 3))
    .attr("dx", button_width/2)
    .style("text-anchor", "middle")
    .text(function(d) { return d; });

/* === focus chart === */

focus.append("g")
    .attr("class", "y axis")
    .call(yAxis)
   	.attr("transform", "translate(" + (width) + ", 0)");

// x-axis
focus.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);

focus.selectAll(".bars")
	.data(dataset)
	.enter().append("rect")
	  		.attr("class", "bar")
	  		.attr("x", function (d) {return x(d.month);	  		})
	  		.attr("y", height)
	  		.attr("height", 0)
	  		.attr("width", x_ordinal.rangeBand())
			.on("mouseover", function(d) {show_tooltip(d)} )
			.on("mouseout", function(d) {hide_tooltip(d)} );
	  	//	.attr("id", function (d) {	  			return d["year"];	  		});

// animate! :)
focus.selectAll(".bar")
	.transition()
	.duration(800)
	.ease("cubic")
	.delay(function(d, i) {

		var maxdelay = 500;
		var z = ((i) / (dataset.length)) * maxdelay;
		var number = z;
		console.log(number)

		return number;
	})
	.attr("y", function (d) {return y(d.count);	  		})
	.attr("height", function (d) {return y(0) - y(d.count);	  		});

/* === tooltip === */
var div = d3.select("#metric-modal").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

/* === context chart === */

context.selectAll(".contextbars")
	.data(dataset)
	.enter().append("rect")
	  		.attr("class", "contextbar")
	  		.attr("x", function (d) {return x_context(d.month);	  		})
	  		.attr("y", function (d) {return y_context(d.count);	  		})
	  		.attr("height", function (d) {return y_context(0) - y_context(d.count);	  		})
	  		.attr("width", x_context_ordinal.rangeBand());


context.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height_context + ")")
    .call(xAxis_context);

/* === brush (part of context chart)  === */

var brushg = context.append("g")
    .attr("class", "x brush")
    .call(brush);

brushg.selectAll(".extent")
   .attr("y", -6)
   .attr("height", height_context + 8);
   // .extent is the actual window/rectangle showing what's in focus

brushg.selectAll(".resize")
    .append("rect")
    .attr("class", "handle")
    .attr("transform", "translate(0," +  -3 + ")")
    .attr('rx', 2)
	.attr('ry', 2)
    .attr("height", height_context + 6)
    .attr("width", 3);

brushg.selectAll(".resize")
    .append("rect")
    .attr("class", "handle-mini")
    .attr("transform", "translate(-2,8)")
    .attr('rx', 3)
    .attr('ry', 3)
    .attr("height", (height_context/2))
    .attr("width", 7);
    // .resize are the handles on either size
    // of the 'window' (each is made of a set of rectangles)

/* === y axis title === */

vis.append("text")
    .attr("class", "y axis title")
    .text("Monthly " + this.metricName)
    .attr("x", (-(height/2)))
    .attr("y", 0)
    .attr("dy", "1em")
    .attr("transform", "rotate(-90)")
    .style("text-anchor", "middle");

// allows zooming before any brush action
zoom.x(x);

/*
* ========================================================================
*  Functions
* ========================================================================
*/

// === tick/date formatting functions ===

function customTickFunction(t0, t1, dt)  {

	var day_in_ms = 86400000;

    var labelSize = 45; //
    var maxTotalLabels = Math.floor(width / labelSize);

    function step(date, offset)  {
        date.setMonth(date.getMonth() + offset);
    }

    var time = d3.time.month.floor(t0),
		time = new Date(time.getTime() + (day_in_ms * 10)), // add a slight offset so that labels are at the center of each month.
		times = [],
		monthFactors = [1,3,4,12];

    while (time < t1) { times.push(new Date(+time)), step(time, 1)};

    var timesCopy = times;
    var i;

    for(i=0 ; times.length > maxTotalLabels ; i++){
        var times = _.filter(timesCopy, function(d){ return (d.getMonth()) % monthFactors[i] == 0; } )
	};

    return times;
};

// === tooltip functions === //
// from: http://bl.ocks.org/d3noob/a22c42db65eb00d4e369

function show_tooltip(d) {

	if (d.count == 1) {
		var metricName_point = metricName.slice(0, -1);
	} else {
		var metricName_point = metricName;
	}

    div.transition()
		.duration(60)
        .style("opacity", 0.98);
    div.html("<b>" + DateFormat(d.month) + "</b><br/>"  + d.count + " " + metricName_point)
        .style("left", (d3.event.pageX -30) + "px")//(d3.event.pageX) + "px"
        .style("top", (d3.event.pageY -40) + "px");//(d3.event.pageY - 28) + "px"
    };

function hide_tooltip(d) {
            div.transition()
                .duration(60)
                .style("opacity", 0);
};


// === brush and zoom functions ===

function brushed() {
    x.domain(brush.empty() ? x_context.domain() : brush.extent());
	common_behaviour();
    // Reset zoom scale's domain
    zoom.x(x);
    updateDisplayDates();

}

function draw() {

    common_behaviour();
    // Force changing brush range
    brush.extent(x.domain());
    vis.select(".brush").call(brush);
    // and update the text showing range of dates.
    updateDisplayDates();
}

function common_behaviour() {

	// custom zoom scale needed to calculate width of bars with zoom/brush.
	// can't use zoom.scale() because this needs to be reset (to one) when using brushed()
	var x_current_width = x.domain()[1] - x.domain()[0],
		x_total_width = dataXrange[1] - dataXrange[0],
		custom_zoom_scale = x_total_width/x_current_width;

	// subset data by current x.domain:
	// var bisectDate = d3.bisector(function(d) { return d.month; }).right;
	// var iL = bisectDate(dataset, x.domain()[0]);//xleft);
	// var iR = bisectDate(dataset, x.domain()[1]) + 1;
	// var dataSubset = dataset.slice(iL,iR);

	// the subset of the data in focus:
	var dataSubset = dataset.filter( function(d) {
		return d.month <= x.domain()[1] && d.month >= x.domain()[0]
	});
	// the minimum needs to be x.domain()[1] minus one month (because width of bar is approx one month)

	var yMaxFocus = d3.max(dataSubset, function(d) { return d.count; }) || 1;


	// reset and redraw the other axes
	y.domain([0, yMaxFocus]);

	// redraw
	focus.select(".x.axis").call(xAxis);
	focus.select(".y.axis").call(yAxis);
	focus.selectAll(".bar")
		.attr("x", function (d) {return x(d.month);	  		})
		.attr("y", function (d) {return y(d.count);	  		})
		.attr("height", function (d) {return y(0) - y(d.count);	  		})
		.attr("width", x_ordinal.rangeBand() * custom_zoom_scale);
};

function brushend() {
// when brush stops moving:

    // check whether chart was scrolled out of bounds and fix,
    var b = brush.extent();
    var out_of_bounds = brush.extent().some(function(e) { return e < mindate | e > maxdate; });
    if (out_of_bounds){ b = moveInBounds(b) };

};

function updateDisplayDates() {

    var b = brush.extent();
    // update the text that shows the range of displayed dates
    var localBrushDateStart = (brush.empty()) ? DateFormat(dataXrange[0]) : DateFormat(b[0]),
        localBrushDateEnd   = (brush.empty()) ? DateFormat(dataXrange[1]) : DateFormat(b[1]);

    // Update start and end dates in upper right-hand corner
    d3.select("#displayDates")
        .text(localBrushDateStart == localBrushDateEnd ? localBrushDateStart : localBrushDateStart + " - " + localBrushDateEnd);
};

function moveInBounds(b) {
// move back to boundaries if user pans outside min and max date.

    var ms_in_year = 31536000000,
        brush_start_new,
        brush_end_new;

    if       (b[0] < mindate)   { brush_start_new = mindate; }
    else if  (b[0] > maxdate)   { brush_start_new = new Date(maxdate.getTime() - ms_in_year); }
    else                        { brush_start_new = b[0]; };

    if       (b[1] > maxdate)   { brush_end_new = maxdate; }
    else if  (b[1] < mindate)   { brush_end_new = new Date(mindate.getTime() + ms_in_year); }
    else                        { brush_end_new = b[1]; };

    brush.extent([brush_start_new, brush_end_new]);

    brush(d3.select(".brush").transition());
    brushed();
    draw();

    return(brush.extent())
};

function scaleDate(d,i) {
// action for buttons that scale focus to certain time interval

    var b = brush.extent(),
        interval_ms,
        brush_end_new,
        brush_start_new;

    if      (d == "year")   { interval_ms = 31536000000}
    else if (d == "month")  { interval_ms = 2592000000 };

    if ( d == "year" | d == "month" )  {

        if((maxdate.getTime() - b[1].getTime()) < interval_ms){
        // if brush is too far to the right that increasing the right-hand brush boundary would make the chart go out of bounds....
            brush_start_new = new Date(maxdate.getTime() - interval_ms); // ...then decrease the left-hand brush boundary...
            brush_end_new = maxdate; //...and set the right-hand brush boundary to the maxiumum limit.
        } else {
        // otherwise, increase the right-hand brush boundary.
            brush_start_new = b[0];
            brush_end_new = new Date(b[0].getTime() + interval_ms);
        };

    } else if ( d == "data")  {
        brush_start_new = dataXrange[0];
        brush_end_new = dataXrange[1]
    } else {
        brush_start_new = b[0];
        brush_end_new = b[1];
    };

    brush.extent([brush_start_new, brush_end_new]);

    // now draw the brush to match our extent
    brush(d3.select(".brush").transition());
    // now fire the brushstart, brushmove, and brushend events
    brush.event(d3.select(".brush").transition());
};

</script>
</body>
