<!DOCTYPE html>
<meta charset="utf-8">
<style>

/**********************************************************
*	  Metric Modal Chart (Views, Downloads, Citations)	  *
***********************************************************/

/*
============ GENERAL CHART TEXT STYLE ===========		[metric modal chart]
*/

#metric-modal .metric-chart text {
	fill: #565656;
	font-size: 9px;
	font-family: Helvetica, Arial, "sans serif";
}

/*
============ WHEN THERE IS NO DATA: ===========		[metric modal chart]
*/

#metric-modal .metric-chart text.no-data {
	font-size: 16px;
	font-weight: 100;
	fill:#d0d0d0;
}

#metric-modal .metric-chart rect.no-data {
	fill: #f5f5f5;
}

/*
	============ WHEN THERE IS DATA: ===========		[metric modal chart]
*/

#metric-modal {/* CB: padding to display better on bl.ocks.org */
	padding: 64px;
}

/*
	--- AXES ---		[metric modal chart]
*/

/* --- x axis focus --- */

#metric-modal .metric-chart .focus .axis {
	shape-rendering: crispEdges;
}

#metric-modal .metric-chart .focus .x.axis {
	clip-path: url(#clip);
}

#metric-modal .metric-chart .focus .x.axis line {
	stroke: white;
	opacity: 0.4;
}

/* --- x axis context --- */

#metric-modal .metric-chart .context .x.axis line {
	display: none;
}


#metric-modal .metric-chart .context .x.axis .domain {
	display:none;
}

/* --- focus y-axis --- */

#metric-modal .metric-chart .focus .y.axis .domain {
	display: none;
}

#metric-modal .metric-chart .y.axis.title {
	font-size: 13px;
	font-weight: 100;
}

/* horizontal focus gridlines */
#metric-modal .metric-chart .y.axis line {
	stroke: #565656;
	stroke-dasharray: 2,2;
	stroke-opacity: 0.3;
}

/*
	--- BRUSH ---		[metric modal chart]
*/

/* --- brush window --- */

#metric-modal .metric-chart .brush .extent {
  fill-opacity: .07;
  shape-rendering: crispEdges;
  clip-path: url(#clip);
  fill: #70706c;
}

/* --- brush handles --- */

#metric-modal .metric-chart .resize .handle {
	fill: #555;
}

#metric-modal .metric-chart .resize .handle-mini {
	fill: white;
    stroke-width: 1px;
    stroke: #555;
}


/*
	--- ZOOM TO BUTTONS ---		[metric modal chart]
*/

#metric-modal .metric-chart .scale_button {
	cursor: pointer;
}

#metric-modal .metric-chart .scale_button rect {
	fill: #eaeaea;
}

#metric-modal .metric-chart .scale_button:hover text {
	fill: white;
	transition: all 0.1s cubic-bezier(.25,.8,.25,1);
}

#metric-modal .metric-chart .scale_button:hover rect {
	fill: #00AA8D;
	transition: all 0.1s cubic-bezier(.25,.8,.25,1);
}

/*
	--- EXPLANATORY TEXT (# views/downloads) ---		[metric modal chart]
*/

#metric-modal .metric-chart text#totalCount  {
	font-size: 15px;
	font-weight: bold;
}

#metric-modal .metric-chart text#displayDates  {
	font-weight: bold;
}

/*
	--- BARS ---		[metric modal chart]
*/

/* --- focus bars --- */

#metric-modal .metric-chart .bar {
	fill: #00AA8D;
	/* stroke: ; /* default, changed in each theme */ */
	stroke-width: 1.5px;
	clip-path: url(#clip);
	cursor: default;
	transition: stroke-width 0.06s ease-in;
	transition: stroke 0.06s ease-in;
}

#metric-modal .metric-chart .bar:hover {
	stroke: #00b798;
	fill: #00b798;
	stroke-width: 1px;
	transition: stroke-width 0.06s ease-out;
	transition: stroke 0.06s ease-out;
}

/* --- context bars --- */

#metric-modal .metric-chart .contextbar {
	fill: #00AA8D;
}

/*
	--- CURSORS ---		[metric modal chart]
*/

#metric-modal .metric-chart rect.pane {
	cursor: move; /* fallback if grab cursor is unsupported */
	cursor: grab;
	fill: #FAFAFA;
	pointer-events: all;
}

#metric-modal .metric-chart rect.pane:active {
	cursor: move; /* fallback if grab cursor is unsupported */
	cursor: grabbing;
}

/*
	--- TOOLTIPS ---		[metric modal chart]
*/

div.tooltip {
    position: fixed;
    text-align: center;
    width: 60px;
    height: 25px;
    padding: 2px;
    font: 10px sans-serif;
    background: white;
	color: #565656;
    border: 0px;
    border-radius: 2px;
    pointer-events: none;
	box-shadow: 0 0px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);

}
</style>

<body>

<div id="metric-modal"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
<script src="//d3js.org/d3.v3.min.js"></script>

<script>

// example data
var metricName   = "views";
var metricCount  = [1, 3, 1, 2, 1, 1, 1, 1, 2, 2, 3, 1, 2, 1, 4, 3, 2, 1, 1, 1, 1, 1, 4, 2, 1, 2, 1, 2, 1, 4, 2, 4, 7, 3, 1, 2, 1, 1, 3, 1, 1, 5, 1, 1, 4];
var metricMonths = ["2018-06", "2013-04", "2015-11", "2012-10", "2014-09", "2014-02", "2016-02", "2016-04", "2016-06", "2014-12", "2013-07", "2017-01", "2015-10", "2012-12", "2013-05", "2018-04", "2015-06", "2017-03", "2014-08",
                    "2017-07", "2013-02", "2012-07", "2016-03", "2017-06", "2018-07", "2014-10", "2013-01", "2013-10", "2017-11", "2014-05", "2012-11", "2015-01", "2018-03", "2015-12", "2015-08", "2016-08", "2014-11", "2014-01",
                    "2013-06", "2012-08", "2015-09", "2016-07", "2013-03", "2012-09", "2016-05"];
var optwidth        = 600;
var optheight       = 370;

/*
* ========================================================================
*  Prepare data
* ========================================================================
*/

// Combine the months and count array to make "data"
var dataset = [];

for(var i=0; i<metricCount.length; i++){

	var monthStart = d3.time.format("%Y-%m").parse(metricMonths[i]);
	var monthMid   = d3.time.day.offset(monthStart, -10);

    var obj = {
		count:	metricCount[i],
		month:  monthStart
	};

    dataset.push(obj);
}

// sort dataset by month
dataset.sort(function(x, y){
   return d3.ascending(x.month, y.month);
});


// ======= find missing data: make an array of months that are missing dataset

// change dates to milliseconds
metricMonths.forEach(function(part, index, theArray) {
  theArray[index] = d3.time.format("%Y-%m").parse(part).getTime();
});

// get a list of all months in the range of data
var monthArray = d3.time.scale()
                .domain(d3.extent(metricMonths))
                .ticks(d3.time.months, 1);

// check if there is data for each month in monthArray, if so append count, otherwise append null
var missing_data = [];
for(var i=0; i<monthArray.length; i++){
	// if no match for month in dataset
	if (metricMonths.indexOf(monthArray[i].getTime()) == -1) {
		// add month to missing_data
		missing_data.push({month: monthArray[i]});
	}
};

/*
* ========================================================================
*  sizing
* ========================================================================
*/

/* === Focus chart === */

var margin	= {top: 30, right: 30, bottom: 95, left: 20},
    width	= optwidth - margin.left - margin.right,
    height	= optheight - margin.top - margin.bottom;

/* === Context chart === */

var margin_context = {top: 315, right: 30, bottom: 20, left: 20},
    height_context = optheight - margin_context.top - margin_context.bottom;

/*
* ========================================================================
*  x and y coordinates
* ========================================================================
*/

var day_in_ms = 86400000;

// add about a month to the end of the x range to show the last bar (which starts on the first of the month)
var dataXrange = d3.extent(dataset, function(d) { return d.month; });//,
	new_max_date = new Date(dataXrange[1].getTime() + (day_in_ms * 27)),
	dataXrange = [dataXrange[0], new_max_date];

var dataYrange = [0, d3.max(dataset, function(d) { return d.count; })];

// maximum date range allowed to display
var mindate = dataXrange[0],  // use the range of the data
    maxdate = dataXrange[1];

var DateFormat	  =  d3.time.format("%b %Y");

/* === Focus Chart === */

var x = d3.time.scale()
	.range([0, width])
    .domain(dataXrange);//dataset.map(function(d){ return d.month})

// This fake ordianal scale is used only because of its `rangeBands` method
// to automatially calculate the width of columns of column chart
// for details, see: https://stackoverflow.com/questions/12186366/d3-js-evenly-spaced-bars-on-a-time-scale
var x_ordinal = d3.scale.ordinal()
	.rangeBands([0, width], 0, 25)
    .domain(dataset.map(function(d){ return d.month}));

var y = d3.scale.linear()
	.range([height, 0])
    .domain(dataYrange);

var xAxis = d3.svg.axis()
	.scale(x)
    .orient("bottom")
	.tickSize(-(height))
    .ticks(customTickFunction)
	.tickFormat(format_months);

var yAxis = d3.svg.axis()
	.scale(y)
    .ticks(4)
	.tickFormat(d3.format("d"))
    .tickSize(-(width))
	.orient("right");

/* === Context Chart === */

var x_context = d3.time.scale()
    .range([0, width])
    .domain([mindate, maxdate]);

var x_context_ordinal = d3.scale.ordinal()
	.rangeBands([0, width], 0, 35)
    .domain(dataset.map(function(d){ return d.month}));

var y_context = d3.scale.linear()
	.range([height_context, 0])
    .domain(y.domain());

var xAxis_context = d3.svg.axis()
    .scale(x_context)
    .orient("bottom")
    .ticks(customTickFunction)
    .tickFormat(format_months);

/*
* ========================================================================
*  Variables for brushing and zooming behaviour
* ========================================================================
*/

var brush = d3.svg.brush()
    .x(x_context)
    .on("brush", brushed)
    .on("brushend", brushend);

var zoom = d3.behavior.zoom()
    .on("zoom", draw)
    .on("zoomend", brushend);

/*
* ========================================================================
*  Define the SVG area ("vis") and append all the layers
* ========================================================================
*/

// === the main components === //

var vis = d3.select("#metric-modal").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  	.attr("class", "metric-chart");// CB -- "line-chart" -- CB //

vis.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("width", width)
    .attr("height", height);
    // clipPath is used to keep elements from moving outside of plot area when user zooms/scrolls/brushes


var pane = vis.append("svg:rect")
    .attr("class", "pane")
    .attr("width", width)
    .attr("height", height)
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var context = vis.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin_context.left + "," + margin_context.top + ")");

var focus = vis.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

pane.call(zoom)
	.call(draw);

// === current date range text & zoom buttons === //

var expl_text = vis.append("g")
    .attr("id", "buttons_group")
    .attr("transform", "translate(" + 0 + ","+ 0 +")");

expl_text.append("text")
	.attr("id", "totalCount")
    .style("text-anchor", "start")
    .attr("transform", "translate(" + 18 + ","+ 11 +")");

expl_text.append("text")
    .attr("id", "displayDates")
    .style("text-anchor", "start")
    .attr("transform", "translate(" + 20 + ","+ 22 +")");

updateDisplayDates();

// === the zooming/scaling buttons === //

var button_width = 40;
var button_height = 14;
var button_padding = 10;

// don't show year button if < 1 year of data
var dateRange  = dataXrange[1] - dataXrange[0],
    ms_in_year = 31540000000;

if (dateRange < ms_in_year)   {
    var button_data =["month","data"];
} else {
   var button_data =["year","month","data"];
};

var button_count = button_data.length -1;
var button_g_width = button_count*button_width + button_count*button_padding + margin.right - button_padding;

// ================
expl_text.append("text")
    .text("Zoom to")
    .style("text-anchor", "start")
    .attr("transform", "translate(" + (width - button_g_width - 45) + ","+ 14 +")");

var button = expl_text.selectAll("g")
    .data(button_data)
    .enter().append("g")
    .attr("class", "scale_button")
    .attr("transform", function(d, i) { return "translate(" + ((width - button_g_width) + i*button_width + i*button_padding) + ",4)"; })
    .on("click", scaleDate);

button.append("rect")
    .attr("width", button_width)
    .attr("height", button_height)
    .attr("rx", 1)
    .attr("ry", 1);

button.append("text")
    .attr("dy", (button_height/2 + 3))
    .attr("dx", button_width/2)
    .style("text-anchor", "middle")
    .text(function(d) { return d; });

/* === focus chart === */

focus.append("g")
    .attr("class", "y axis")
    .call(yAxis)
   	.attr("transform", "translate(" + (width) + ", 0)");

// x-axis
focus.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);

// MISSING DATA
// focus.selectAll(".missing_data")
// 	.data(missing_data)
// 	.enter().append("rect")
// 	  		.attr("class", "missing_rect")
// 	  		.attr("x", function (d) {return x(d.month);})
// 	  		.attr("y", y(7))
// 	  		.attr("height", y(-0.1)-y(7))
// 	  		.attr("width", x_ordinal.rangeBand()+2)
// 			.attr("fill", "white");

focus.selectAll(".bars")
	.data(dataset)
	.enter().append("rect")
	  		.attr("class", "bar")
	  		.attr("x", function (d) {return x(d.month);	  		})
	  		.attr("y", height)
	  		.attr("height", 0)
	  		.attr("width", x_ordinal.rangeBand())
			.on("mouseover", function(d) {show_tooltip(d)} )
			.on("mouseout", function(d) {hide_tooltip(d)} )
			.style("opacity", 0);

// animate! :)
focus.selectAll(".bar")
	.transition()
	.duration(450)
	.ease("elastic", 1.03, 0.98)
	.delay(function(d, i) {
		var max_delay = 600;
		var z = i / (dataset.length-1);
		var line_z =  z * max_delay * 0.4;
		var log_z = Math.log2(z + 1) * max_delay * 0.6;
		return(250+line_z + log_z);
	})
	.attr("y", function (d) {return y(d.count);	  		})
	.attr("height", function (d) {return y(0) - y(d.count);	  		})
	.style("opacity", 1);

/* === tooltip === */
var div = d3.select("#metric-modal").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

/* === context chart === */

context.selectAll(".contextbars")
	.data(dataset)
	.enter().append("rect")
	  		.attr("class", "contextbar")
	  		.attr("x", function (d) {return x_context(d.month);	  		})
	  		.attr("y", height_context)
	  		.attr("height", 0)
	  		.attr("width", x_context_ordinal.rangeBand())
			.style("opacity", 0);

// animate! :)
context.selectAll(".contextbar")
	.transition()
	.duration(450)
	.ease("elastic", 1.03, 0.98)
	.delay(function(d, i) {
		var max_delay = 600;
		var z = i / (dataset.length-1);
		var line_z =  z * max_delay * 0.4;
		var log_z = Math.log2(z + 1) * max_delay * 0.6;
		return(line_z + log_z);
	})
	.attr("y", function (d) {return y_context(d.count);	  		})
	.attr("height", function (d) {return y_context(0) - y_context(d.count);	  		})
	.style("opacity", 1);

context.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height_context + ")")
    .call(xAxis_context);

/* === brush (part of context chart)  === */

var brushg = context.append("g")
    .attr("class", "x brush")
    .call(brush);

brushg.selectAll(".extent")
   .attr("y", -6)
   .attr("height", height_context + 8);
   // .extent is the actual window/rectangle showing what's in focus

brushg.selectAll(".resize")
    .append("rect")
    .attr("class", "handle")
    .attr("transform", "translate(0," +  -3 + ")")
    .attr('rx', 2)
	.attr('ry', 2)
    .attr("height", height_context + 6)
    .attr("width", 3);

brushg.selectAll(".resize")
    .append("rect")
    .attr("class", "handle-mini")
    .attr("transform", "translate(-2,8)")
    .attr('rx', 3)
    .attr('ry', 3)
    .attr("height", (height_context/2))
    .attr("width", 7);
    // .resize are the handles on either size
    // of the 'window' (each is made of a set of rectangles)

/* === y axis title === */

vis.append("text")
    .attr("class", "y axis title")
    .text("Monthly " + this.metricName)
    .attr("x", (-((height+margin.top+margin.bottom-50)/2)))
    .attr("y", 0)
    .attr("dy", "1em")
    .attr("transform", "rotate(-90)")
    .style("text-anchor", "middle");

// allows zooming before any brush action
zoom.x(x);

/*
* ========================================================================
*  Functions
* ========================================================================
*/

// === tick/date formatting functions ===

function customTickFunction(t0, t1, dt)  {

    var labelSize = 45; //
    var maxTotalLabels = Math.floor(width / labelSize);

    function step(date, offset)  {
        date.setMonth(date.getMonth() + offset);
    }

    var time = d3.time.month.floor(t0),
		time = new Date(time.getTime() + (day_in_ms * 10)), // add a slight offset so that labels are at the center of each month.
		times = [],
		monthFactors = [1,3,4,12];

    while (time < t1) { times.push(new Date(+time)), step(time, 1)};

    var timesCopy = times;
    var i;

    for(i=0 ; times.length > maxTotalLabels ; i++){
        var times = _.filter(timesCopy, function(d){ return (d.getMonth()) % monthFactors[i] == 0; } )
	};

    return times;
};

function format_months(d){

	var test = (x.domain()[1] - x.domain()[0]) > 132167493818;

	if(d.getMonth()==0 & test){//if january
		var yearOnly = d3.time.format("%Y");
		return(yearOnly(d));
	} else {
		return(DateFormat(d))
	}
}

// === tooltip functions === //
// from: http://bl.ocks.org/d3noob/a22c42db65eb00d4e369

function show_tooltip(d) {

	// remove s from metric name if count is 1
	if (d.count == 1) {
		var metricName_point = metricName.slice(0, -1);
	} else {
		var metricName_point = metricName;
	}

	// custom zoom scale needed to calculate width of bars with zoom/brush.
	// can't use zoom.scale() because this needs to be reset (to one) when using brushed()
	var x_current_width = x.domain()[1] - x.domain()[0],
		x_total_width = dataXrange[1] - dataXrange[0],
		custom_zoom_scale = x_total_width/x_current_width;

    div.transition()
		.duration(60)
        .style("opacity", 0.98);

    div.html("<b>" + DateFormat(d.month) + "</b><br/>"  + d.count + " " + metricName_point)
        .style("left", (x(d.month) + 57 + (x_ordinal.rangeBand() * 0.5 * custom_zoom_scale)) + "px")
		.style("top", (y(d.count)+68) + "px");
    };

function hide_tooltip(d) {
            div.transition()
                .duration(60)
                .style("opacity", 0);
};


// === brush and zoom functions ===

function brushed() {
    x.domain(brush.empty() ? x_context.domain() : brush.extent());
	common_behaviour();
    // Reset zoom scale's domain
    zoom.x(x);
    updateDisplayDates();

}

function draw() {

    common_behaviour();
    // Force changing brush range
    brush.extent(x.domain());
    vis.select(".brush").call(brush);
    // and update the text showing range of dates.
    updateDisplayDates();
}

function common_behaviour() {

	// custom zoom scale needed to calculate width of bars with zoom/brush.
	// can't use zoom.scale() because this needs to be reset (to one) when using brushed()
	var x_current_width = x.domain()[1] - x.domain()[0],
		x_total_width = dataXrange[1] - dataXrange[0],
		custom_zoom_scale = x_total_width/x_current_width;

	// given bar width, date range should switch to next month on the 24th.
	var left_date = x.domain()[0];
	if(left_date.getDate() < 24){
		var left_date = d3.time.month.floor(left_date),
			left_date = new Date(left_date.getTime())
	};

	var dataSubset = dataset.filter( function(d) {
		return d.month <= x.domain()[1] && d.month >= left_date
	});

	var yMaxFocus = d3.max(dataSubset, function(d) { return d.count; }) || 1;

	// reset and redraw the other axes
	y.domain([0, yMaxFocus]);

	// redraw
	focus.select(".x.axis").call(xAxis);
	focus.select(".y.axis").call(yAxis);
	focus.selectAll(".bar")
		.attr("x", function (d) {return x(d.month);	  		})
		.attr("y", function (d) {return y(d.count);	  		})
		.attr("height", function (d) {return y(0) - y(d.count);	  		})
		.attr("width", x_ordinal.rangeBand() * custom_zoom_scale);
};

function brushend() {
// when brush stops moving:

    // check whether chart was scrolled out of bounds and fix,
    var b = brush.extent();
    var out_of_bounds = brush.extent().some(function(e) { return e < mindate | e > maxdate; });
    if (out_of_bounds){ b = moveInBounds(b) };

};

function updateDisplayDates() {

    var b = brush.extent();

	// given bar width, date range should switch to next month on the 24th.
	if(b[0].getDate() >= 24){
		var left_date = d3.time.month.ceil(b[0]),
			left_date = new Date(left_date.getTime())
	} else {
		left_date = d3.time.month.floor(b[0])
	}

    // update the text that shows the range of displayed dates
    var start_month = (brush.empty()) ? DateFormat(dataXrange[0]) : DateFormat(left_date),
        end_month   = (brush.empty()) ? DateFormat(dataXrange[1]) : DateFormat(b[1]);

	var dataSubset = dataset.filter( function(d) {
		return d.month <= DateFormat.parse(end_month) && d.month >= left_date
	});

	var total_count = 0;
        for (var i = 0; i < dataSubset.length; i++) {
            total_count += dataSubset[i].count;
    }

    // Update start and end dates in upper right-hand corner
    d3.select("#displayDates")
        .text(start_month == end_month ? "in " + start_month : "from " + start_month + " to " + end_month);

	d3.select("#totalCount")
		.text(total_count + " " + this.metricName);

	// Fade all years in the bar chart not within the brush
    context.selectAll(".contextbar")
		.style("opacity", function(d, i) {
      		return  d.month <= DateFormat.parse(end_month) && d.month >= left_date || brush.empty() ? "1" : ".3";
    });

};

function moveInBounds(b) {
// move back to boundaries if user pans outside min and max date.

    var ms_in_year = 31536000000,
        brush_start_new,
        brush_end_new;

    if       (b[0] < mindate)   { brush_start_new = mindate; }
    else if  (b[0] > maxdate)   { brush_start_new = new Date(maxdate.getTime() - ms_in_year); }
    else                        { brush_start_new = b[0]; };

    if       (b[1] > maxdate)   { brush_end_new = maxdate; }
    else if  (b[1] < mindate)   { brush_end_new = new Date(mindate.getTime() + ms_in_year); }
    else                        { brush_end_new = b[1]; };

    brush.extent([brush_start_new, brush_end_new]);

    brush(d3.select(".brush").transition());
    brushed();
    draw();

    return(brush.extent())
};

function scaleDate(d,i) {
// action for buttons that scale focus to certain time interval

    var b = brush.extent(),
        interval_ms,
        brush_end_new,
        brush_start_new;

    if      (d == "year")   { interval_ms = 31536000000}
    else if (d == "month")  { interval_ms = 2592000000 };

    if ( d == "year" | d == "month" )  {

        if((maxdate.getTime() - b[1].getTime()) < interval_ms){
        // if brush is too far to the right that increasing the right-hand brush boundary would make the chart go out of bounds....
            brush_start_new = new Date(maxdate.getTime() - interval_ms); // ...then decrease the left-hand brush boundary...
            brush_end_new = maxdate; //...and set the right-hand brush boundary to the maxiumum limit.
        } else {
        // otherwise, increase the right-hand brush boundary.
            brush_start_new = b[0];
            brush_end_new = new Date(b[0].getTime() + interval_ms);
        };

    } else if ( d == "data")  {
        brush_start_new = dataXrange[0];
        brush_end_new = dataXrange[1]
    } else {
        brush_start_new = b[0];
        brush_end_new = b[1];
    };

    brush.extent([brush_start_new, brush_end_new]);

    // now draw the brush to match our extent
    brush(d3.select(".brush").transition());
    // now fire the brushstart, brushmove, and brushend events
    brush.event(d3.select(".brush").transition());
};

</script>
</body>
